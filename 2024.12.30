6주차
2024.12.30

1교시(09-10)
SQL 간단 문제와 문제풀이
Q1.
Q2.
Q3.

* 서브쿼리 (SUBQUERY)
- 하나의 SQL문 안에 포함된 또 다른 SELECT 문
- 메인 SQL문을 위해 보조 역할을 하는 쿼리문

간단 쿼리 예시1.
1) 먼저 노옹철 사원의 부서코드 조회
SELECT DEPT_CODE
FROM EMPLOYEE
WHERE EMP_NAME = '노옹철'; -- D9

2) 부서코드가 D9인 사원들 조회
SELECT EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE = 'D9';

-- > 위의 2단계를 하나의 쿼리문으로
SELECT EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE = (
                    SELECT DEPT_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '노옹철'
                    );

간단 서브쿼리 예시2.
1) 전 직원의 평균 급여
SELECT AVG(SALARY)
FROM EMPLOYEE;

2) 급여가 3047663원 이상인 사원들 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= 3047663;

위의 2단계를 하나의 쿼리문으로!!
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY >= (
                SELECT AVG(SALARY) -- 서브쿼리는 이 내용물인 쿼리를 말한다.
                FROM EMPLOYEE
                );
-- 서브쿼리 때는 ()가 필수다.



2교시 (10-11)

* 서브쿼리의 구분
-- 서브쿼리를 수행한 결과값이 몇 행 몇 열이냐에 따라서 분류됨


1. 단일행 서브쿼리 : 서브쿼리의 조회 결과값의 개수가 오로지 1개일 때 (한 행 한 열)
=> 일반 비교 연산자 사용 가능 ( =, !=, ^=, >, <, <=, ... )
EX)
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
-- WHERE SALARY < 전직원의 평균 급여;
WHERE SALARY < (SELECT AVG(SALARY)
                FROM EMPLOYEE);
				
EX) 4_1) 먼저 부서별 급여합 중에서도 가장 큰 값 하나만 조회
SELECT MAX(SUM(SALARY)) -- 이렇게 하는 거구나. 몰랐네.
FROM EMPLOYEE
GROUP BY DEPT_CODE;

4_2) 부서별 급여합계가 17700000원인 부서 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))
                        FROM EMPLOYEE
                        GROUP BY DEPT_CODE);


3교시 (11-12)

2. 다중행 서브쿼리 : 서브쿼리를 수행한 결과값이 여러 행일때 (컬럼은 한개!)
=> IN 서브쿼리 : 여러 개의 결과값 중에서 한개라도 일치하는 값이 있다면

> ANY 서브 쿼리 : 여러 개의 결과값 중에서 "한 개라도" 클 경우 (여러 개의 결과값 중에서 가장 작은 값보다 클 경우)
< ANY 서브 쿼리 : 여러 개의 결과값 중에서 "한 개라도" 작을 경우 (여러 개의 결과값 중에서 가장 큰 값보다 작을 경우)

	비교대상 > ANY (값1, 값2, 값3)
	비교대상 > 값1 OR 비교대상 > 값2 OR 비교대상 > 값3

> ALL 서브 쿼리 : 여러 개의 "모든" 결과값들 보다 클 경우
< ALL 서브 쿼리 : 여러 개의 "모든" 결과값들 보다 작을 경우

	비교대상 > ALL (값1, 값2, 값3)
	비교대상 > 값1 AND 비교대상 > 값2 AND 비교대상 > 값3

EX) 유재식 또는 윤은해 사원과 같은 직급인 사원들의 사번, 사원명, 직급코드, 급여 조회
SELECT JOB_CODE
FROM EMPLOYEE
WHERE EMP_NAME IN ('유재식', '윤은해');

SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE JOB_CODE IN ('J3', 'J7');


-- 위의 두 단계를 하나의 쿼리로
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE JOB_CODE IN (
                    SELECT JOB_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME IN ('유재식', '윤은해') -- = 이라고 쓰면 에러. 여러 행으로 조회됐기 때문!!
                    -- 만약에 결과값이 여러 개 나올 것 같으면 안전하게 IN으로 입력하자.
                    );

EX2) 과장 직급임에도 불구하고 차장직급인 사원들의 모든 급여보다도 더 많이 받는 사원들의 사번, 사원명, 직급명, 급여
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE JOB_NAME = '과장'
-- AND SALARY (차장직급인 애들의 급여들);
AND SALARY > ALL (
                SELECT SALARY
                FROM EMPLOYEE
                JOIN JOB USING (JOB_CODE)
                WHERE JOB_NAME = '차장'
                );


3. 다중열 서브쿼리 : 결과값은 한 행이지만 나열된 컬럼수가 여러 개일 경우
=> 단일행 서브쿼리로도 가능하긴 함

EX)
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE DEPT_CODE = (
                    SELECT DEPT_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '하이유'
                    )
AND JOB_CODE = (
                SELECT JOB_CODE
                FROM EMPLOYEE
                WHERE EMP_NAME = '하이유'
                );
				
-- >> 다중열 서브쿼리
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) = (
                                SELECT DEPT_CODE, JOB_CODE
                                FROM EMPLOYEE
                                WHERE EMP_NAME = '하이유'      -- 순서 중요, 개수 맞춰야 함                          
                                );

EX2)
SELECT EMP_ID "사번", EMP_NAME "사원명", JOB_CODE "직급코드", MANAGER_ID "사수 사번"
FROM EMPLOYEE
WHERE (JOB_CODE, MANAGER_ID) = (
                                SELECT JOB_CODE, MANAGER_ID
                                FROM EMPLOYEE
                                WHERE EMP_NAME = '박나라'
                                );


4교시 (12-13)

4. 다중행 다중열 서브 쿼리 : 서브쿼리 조회 결과값이 여러 행 여러 열일 경우
* (여러 개일 것 같으면 그냥 IN을 써라)

EX)
SELECT DEPT_CODE, MAX(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE(DEPT_CODE, SALARY) IN (SELECT DEPT_CODE, MAX(SALARY)
                            FROM EMPLOYEE
                            GROUP BY DEPT_CODE);


5. 인라인 뷰(INLINE-VIEW) : 서브쿼리를 수행한 결과를 마치 테이블처럼 사용!
인라인 뷰를 주로 사용하는 예시
=> TOP - N 분석
(상위 몇 개만 보여주고 싶을 때)

EX)
SELECT EMP_ID, EMP_NAME, (SALARY + SALARY * NVL(BONUS, 0))*12 AS "연봉", DEPT_CODE
FROM EMPLOYEE;

=>
SELECT *
-- FROM 테이블명
FROM (SELECT EMP_ID, EMP_NAME, (SALARY + SALARY * NVL(BONUS, 0))*12 AS "연봉", DEPT_CODE
FROM EMPLOYEE)
WHERE 연봉 >= 30000000;

* ROWNUM : 오라클에서 제공해주는 가상컬럼, 조회된 순서대로 1부터 순번을 부여해주는 컬럼
=> FROM 절을 읽고나서, SELECT ROWNUM 순번이 부여됨. 정렬도 하기 이전.

해결방법!
EX)
SELECT ROWNUM, E.*
FROM (SELECT EMP_NAME, SALARY, DEPT_CODE
        FROM EMPLOYEE
        ORDER BY SALARY DESC) E
WHERE ROWNUM <= 5;


5교시 (14-15)

순위를 매기는 함수 (WINDOW FUNCTION)
RANK() OVER (정렬기준) : 동일한 순위 이후의 등수를 동일한 인원수 만큼 건너뛰고 순위 계산
EX)
SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) "순위"
FROM EMPLOYEE;
-- 공동 19위 2명 그 뒤의 순위는 21 => 마지막 순위량 조회된 행수가 같음

DENSE_RANK() OVER(정렬기준) : 동일한 순위가 있다고 해도 그 다음 등수를 무조건 1씩 증가
EX)
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) "순위"
FROM EMPLOYEE;
-- 공동 19위 2명 그 뒤의 순위는 20 => 마지막 순위량 조회된 행수가 다름

>> 두 함수는 무조건 SELECT 절에서만 사용 가능!!
EX)
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) "순위"
FROM EMPLOYEE
WHERE DENSE_RANK() OVER(ORDER BY SALARY DESC) <= 5;
-- functions are not allowed here, 오류가 발생

-->>  인라인 뷰를 사용해야 순위를 사용할 수 있다.
SELECT *
FROM(SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) "순위"
FROM EMPLOYEE)
WHERE 순위 <= 5;


